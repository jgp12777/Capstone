
using System;
using System.Net.Sockets; 
using System.Text; 
using System.Text.Json;      
using System.Globalization;
using System.Net;
using System.Net.WebSockets;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Linq;


//---------------------------------------------------------------------------------
//------------------------simple settings------------------------------------------
//---------------------------------------------------------------------------------

double onThreshold  = 0.6; // turns an action ON
double offThreshold = 0.5; // turns action OFF (hysteresis)
int DebounceMs = 150;         // require actions to stay stable this long
int rateHz = 15;        // cap frequency 
int udpPort = 7400;
int httpPort = 8080;   // used by the WebSocket server (ws://127.0.0.1:8080/stream)

bool keyboardMode = false;  // default: OFF for safety
// Parse CLI flags: --keys to enable, --no-keys to force disable
foreach (var arg in args)
{
    if (arg.Equals("--keys", StringComparison.OrdinalIgnoreCase))
        keyboardMode = true;
    else if (arg.Equals("--no-keys", StringComparison.OrdinalIgnoreCase))
        keyboardMode = false;
}



//---------------------------------------------------------------------------------
//-----------------------Status Variables------------------------------------------
//---------------------------------------------------------------------------------

string active = "neutral";  // confirmed clean action
string candidate = "neutral"; //potential new action 
DateTime candidateSince = DateTime.UtcNow; //when we start considering the action
double lastConfidence = 0.0;     // last seen confidence
DateTime activeSince = DateTime.UtcNow; //When currect action become active
string lastSource = "csv"; // "osc" when we parse OSC successfully
ushort currentKeyDown = 0;  // which virtual key is currently held (0 = none)



//rate limits
int intervalMs = Math.Max(1,(int)Math.Round(1000.0 / rateHz));
DateTime lastPrintAt    =DateTime.MinValue;
string lastPrintedLine = "";
string lastJson = "";        // drop duplicates

//webSocket Clients
var clients = new System.Collections.Generic.List<WebSocket>();
object clientslock = new();



Console.WriteLine("------------------------------------------------");
Console.WriteLine("BrainWrapper (UDP → filtered → WebSocket + console)");
Console.WriteLine($"UDP in:           :{udpPort}");
Console.WriteLine($"WebSocket out:    ws://127.0.0.1:{httpPort}/stream");
Console.WriteLine($"HTTP:            http://127.0.0.1:{httpPort}/state , /healthz");
Console.WriteLine("Send:             action,confidence   e.g.  push,0.82");
Console.WriteLine($"Debounce:         {DebounceMs} ms");
Console.WriteLine($"Rate limit:       {rateHz} Hz");
Console.WriteLine($"Keyboard mode:    {(keyboardMode ? "ON  (--keys)" : "OFF (default, use --keys)")}"); 
Console.WriteLine("------------------------------------------------");


//---------------------------------------------------------------------------------
//----------------------------------Start websocket server-------------------------
//---------------------------------------------------------------------------------
StartHttpAndWebSocketServer();

using var udp = new UdpClient(new IPEndPoint(IPAddress.Loopback, udpPort));







//---------------------------------MAIN loop------------------------------------------------------------------------
while (true)
{
    try
    {
        if (udp.Available > 0)
        {


            var res = await udp.ReceiveAsync(); //1 UDP packet
            const int MaxPacket = 2048; // tune as needed
            if (res.Buffer.Length == 0 || res.Buffer.Length > MaxPacket)
                continue;

            string action;
            double conf;

            // 1) Try OSC (binary datagram → address + typetags + args)
            if (TryParseOsc(res.Buffer, out action, out conf))
            {
                lastSource = "osc";
                lastConfidence = conf;
            }
            else
            {
                // 2) Fallback to CSV: "action,confidence"
                string text = Encoding.UTF8.GetString(res.Buffer).Trim();
                var parts = text.Split(',');
                if (parts.Length != 2) continue;

                action = parts[0].Trim().ToLowerInvariant();
                if (!double.TryParse(parts[1], NumberStyles.Float, CultureInfo.InvariantCulture, out conf)) continue;

                lastSource = "csv";
                lastConfidence = conf;
            }

            //----------------------------filters----------------------------------------------------------------------------


            string desired = active; //start from current state
                                     // tiny cleaning rules:
            if (conf >= onThreshold && action != "neutral") // strong singal switch to that action
            {
                desired = action;     // switch to action
            }
            else if (conf < offThreshold) // Weak signal switch to neutral
            {
                desired = "neutral"; // fall back to neutral
            }


            //apply Debounce
            var now = DateTime.UtcNow;

            if (desired != candidate)
            {
                // new candidate action; timer resets
                candidate = desired;
                candidateSince = now;
            }
            else
            {
                // candidate stayted the same; check dwell time
                var dwellMs = (now - candidateSince).TotalMilliseconds;
                if (dwellMs >= DebounceMs && active != candidate)
                {
                    active = candidate;      // passed debounce time makes it official
                    activeSince = now;       // reset duration timer
                    UpdateKeyboard(active);  //key sync keyboard with new action
                }

            }
        }
    

    {
        var now = DateTime.UtcNow;
        if ((now - lastPrintAt).TotalMilliseconds >= intervalMs)
        {
            lastPrintAt = now;

            // Build status line for console
            string line = $"active={active}  (candidate={candidate}, conf={lastConfidence:0.00})";

            // Build JSON event for WebSocket clients
            int durationMs = (int)Math.Max(0, (now - activeSince).TotalMilliseconds);
            string json = BuildJson(active, lastConfidence, durationMs, lastSource);

            // Console: only print if it changed
            if (line != lastPrintedLine)
            {
                Console.WriteLine(line);
                lastPrintedLine = line;
            }

            // WebSocket: only broadcast if it changed
            if (json != lastJson)
            {
                await BroadcastAsync(json);
                lastJson = json;
            }
        }
    }

    await Task.Delay(5);

    }
catch (Exception ex)
    {
        //catch errors
        Console.WriteLine($"Warning: {ex.Message}");
    }

}

//-----------------------------------------------------------------------
// HELPER: BUILD JSON STRING
//-----------------------------------------------------------------------
string BuildJson(string action, double conf, int durationMs, string source)
{
    var payload = new
    {
        ts = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
        type = "mental_command",
        action = action,
        confidence = conf,
        durationMs = durationMs,
        raw = new { source = source }
    };

    return JsonSerializer.Serialize(payload);
}



//-----------------------------------------------------------------------
// HELPER: bROADCAST A json message to all websocket clients
//-----------------------------------------------------------------------
async Task BroadcastAsync(string json)
{
    byte[] bytes = Encoding.UTF8.GetBytes(json);

    List<WebSocket> snapshot;
    lock (clientslock)
        snapshot = clients.Where(ws => ws.State == WebSocketState.Open).ToList();

    var dead = new List<WebSocket>();

    foreach (var ws in snapshot)
    {
        try
        {
            await ws.SendAsync(new ArraySegment<byte>(bytes),
                               WebSocketMessageType.Text,
                               endOfMessage: true,
                               CancellationToken.None);
        }
        catch
        {
            dead.Add(ws);
        }
    }

    if (dead.Count > 0)
    {
        lock (clientslock)
        {
            foreach (var d in dead)
                clients.Remove(d);
        }

        foreach (var d in dead)
        {
            try { d.Dispose(); } catch { }
        }
    }
}

// Try to parse an OSC packet into (action, confidence).
// Also logs address, tags, and argument values so we can see what Emotiv sends.
bool TryParseOsc(byte[] data, out string action, out double conf)
{
    action = "neutral";
    conf = 0.0;

    try
    {
        int i = 0;

        // 1) Address (e.g. "/Emotiv/MentalCommand")
        string addr = ReadOscString(data, ref i);
        Console.WriteLine($"[OSC-ADDR] {addr}");

        // 2) Typetags (e.g. ",sf" meaning: string, float)
        if (i >= data.Length || data[i] != (byte)',')
        {
            Console.WriteLine("[OSC] no typetags, not OSC?");
            return false;
        }

        string tags = ReadOscString(data, ref i);
        Console.WriteLine($"[OSC-TAGS] {tags}");

        // 3) Read arguments according to typetags
        var values = new List<object>();

        for (int t = 1; t < tags.Length; t++) // skip leading ','
        {
            char tag = tags[t];
            switch (tag)
            {
                case 's':
                    {
                        string s = ReadOscString(data, ref i);
                        values.Add(s);
                        Console.WriteLine($"[OSC-ARG] string: {s}");
                        break;
                    }
                case 'f':
                    {
                        float f = ReadOscFloatBE(data, ref i);
                        values.Add(f);
                        Console.WriteLine($"[OSC-ARG] float: {f}");
                        break;
                    }
                default:
                    // skip/align for unsupported types
                    Align4(ref i);
                    Console.WriteLine($"[OSC-ARG] unsupported tag '{tag}', skipping");
                    break;
            }
        }

        // 4) Simple mapping:
        //    - first string  -> action
        //    - first float   -> confidence
        string? parsedAction = null;
        float?  parsedFloat  = null;

        foreach (var v in values)
        {
            if (v is string s && parsedAction == null)
                parsedAction = s;
            else if (v is float f && !parsedFloat.HasValue)
                parsedFloat = f;
        }

        if (!string.IsNullOrWhiteSpace(parsedAction) && parsedFloat.HasValue)
        {
            action = parsedAction!.Trim().ToLowerInvariant();
            conf = parsedFloat.Value;
            Console.WriteLine($"[OSC-PARSED] action={action}, conf={conf:0.00}");
            return true;
        }

        Console.WriteLine("[OSC] did not find both string action and float confidence");
        return false;
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[OSC-ERROR] {ex.Message}");
        return false;
    }

    // ---------- helpers below ----------

    static string ReadOscString(byte[] buf, ref int idx)
{
    int start = idx;

    // Find null terminator
    while (idx < buf.Length && buf[idx] != 0) idx++;
    if (idx >= buf.Length)
        throw new FormatException("OSC string missing terminator");

    string s = Encoding.ASCII.GetString(buf, start, idx - start);

    // Move past the terminator byte
    idx++;

    // Pad to 4-byte boundary exactly once (OSC rule)
    int pad = (4 - (idx % 4)) % 4;
    idx += pad;

    if (idx > buf.Length)
        throw new FormatException("OSC string padding overrun");

    return s;
}


    // OSC floats are big-endian (network order)
    static float ReadOscFloatBE(byte[] buf, ref int idx)
    {
        if (idx + 4 > buf.Length) return 0f;
        byte b0 = buf[idx], b1 = buf[idx + 1], b2 = buf[idx + 2], b3 = buf[idx + 3];
        idx += 4;

        if (BitConverter.IsLittleEndian)
            return BitConverter.ToSingle(new byte[] { b3, b2, b1, b0 }, 0);
        return BitConverter.ToSingle(new byte[] { b0, b1, b2, b3 }, 0);
    }

    static void Align4(ref int idx)
    {
        int mod = idx % 4;
        if (mod != 0) idx += (4 - mod);
    }
}


//---------------------------------------------------------------------------------------------------------------------
//-------------------------------START WEB SERVER ON ws://127.0.0.1.:8080/stream
//---------------------------------------------------------------------------------------------------------------------

// Starts a localhost HttpListener that serves:
// - WebSocket on /stream
// - HTTP JSON on /state
// - HTTP health on /healthz
void StartHttpAndWebSocketServer()
{
    Task.Run(async () =>
    {
        var listener = new HttpListener();
        // localhost-only for safety
        listener.Prefixes.Add($"http://127.0.0.1:{httpPort}/");
        try
        {
            listener.Start();
        }
        catch (HttpListenerException ex)
        {
            Console.WriteLine("Error: could not start HTTP/WS server.");
            Console.WriteLine("You may need to run as Administrator or reserve the URL.");
            Console.WriteLine(ex.Message);
            return;
        }

        Console.WriteLine($"HTTP/WS listening on http://127.0.0.1:{httpPort}/  (WS: /stream, HTTP: /state, /healthz)");

        while (true)
        {
            HttpListenerContext ctx;
            try { ctx = await listener.GetContextAsync(); }
            catch { break; } // listener stopped

            // 1) WebSocket endpoint: /stream
            if (ctx.Request.IsWebSocketRequest && ctx.Request.RawUrl == "/stream")
            {
                try
                {
                    var wsContext = await ctx.AcceptWebSocketAsync(subProtocol: null);
                    var ws = wsContext.WebSocket;

                    lock (clientslock) clients.Add(ws);

                    // background loop to detect close
                    _ = Task.Run(async () =>
                    {
                        var buffer = new byte[1024];
                        try
                        {
                            while (ws.State == WebSocketState.Open)
                            {
                                var result = await ws.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                                if (result.MessageType == WebSocketMessageType.Close) break;
                            }
                        }
                        catch { /* ignore */ }
                        finally
                        {
                            lock (clientslock) clients.Remove(ws);
                            try { ws.Dispose(); } catch { }
                        }
                    });
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"WebSocket accept error: {ex.Message}");
                    ctx.Response.StatusCode = 500;
                    ctx.Response.Close();
                }
                continue;
            }

            // 2) HTTP: /state -> current JSON snapshot
            if (ctx.Request.HttpMethod == "GET" && ctx.Request.RawUrl == "/state")
            {
                string json = BuildJson(
                    active,
                    lastConfidence,
                    (int)Math.Max(0, (DateTime.UtcNow - activeSince).TotalMilliseconds),
                    lastSource);

                byte[] body = Encoding.UTF8.GetBytes(json);
                ctx.Response.StatusCode = 200;
                ctx.Response.ContentType = "application/json";
                ctx.Response.ContentEncoding = Encoding.UTF8;
                await ctx.Response.OutputStream.WriteAsync(body, 0, body.Length);
                ctx.Response.OutputStream.Close();
                continue;
            }

            // 3) HTTP: /healthz -> {"status":"ok"}
            if (ctx.Request.HttpMethod == "GET" && ctx.Request.RawUrl == "/healthz")
            {
                const string ok = "{\"status\":\"ok\"}";
                byte[] body = Encoding.UTF8.GetBytes(ok);
                ctx.Response.StatusCode = 200;
                ctx.Response.ContentType = "application/json";
                ctx.Response.ContentEncoding = Encoding.UTF8;
                await ctx.Response.OutputStream.WriteAsync(body, 0, body.Length);
                ctx.Response.OutputStream.Close();
                continue;
            }

            // 4) Anything else -> small info text
            {
                string info = $"Endpoints: ws /stream , http GET /state , GET /healthz";
                byte[] body = Encoding.UTF8.GetBytes(info);
                ctx.Response.StatusCode = 200;
                ctx.Response.ContentType = "text/plain";
                await ctx.Response.OutputStream.WriteAsync(body, 0, body.Length);
                ctx.Response.OutputStream.Close();
            }
        }
    });
}

// -----------------------------------------------------------------------
// KEYBOARD EMULATION 
// Maps actions to WASD using Win32 SendInput.
// -----------------------------------------------------------------------

void UpdateKeyboard(string newAction)
{
    if (!keyboardMode)
        return;

    // Map action -> virtual key code
    ushort? newKey = MapActionToKey(newAction);

    // If we have an old key held down and it's changing or going neutral -> release old key
    if (currentKeyDown != 0 && (!newKey.HasValue || newKey.Value != currentKeyDown))
    {
        SendKey(currentKeyDown, KeyEventFlags.KEYUP);
        currentKeyDown = 0;
    }

    // If new key is non-neutral and different -> press new key
    if (newKey.HasValue && newKey.Value != 0 && newKey.Value != currentKeyDown)
    {
        SendKey(newKey.Value, KeyEventFlags.KEYDOWN);
        currentKeyDown = newKey.Value;
    }
}

// Map mental action -> virtual-key code (WASD)
ushort? MapActionToKey(string action)
{
    switch (action.ToLowerInvariant())
    {
        case "push":  return 0x57; // 'W'
        case "pull":  return 0x53; // 'S'
        case "left":  return 0x41; // 'A'
        case "right": return 0x44; // 'D'
        default:      return null; // neutral or unsupported -> no key
    }
}

// Sends a single key press or release using SendInput.
void SendKey(ushort vk, KeyEventFlags flags)
{
    INPUT[] inputs = new INPUT[1];
    inputs[0].type = 1; // INPUT_KEYBOARD
    inputs[0].U.ki.wVk = vk;
    inputs[0].U.ki.wScan = 0;
    inputs[0].U.ki.dwFlags = (uint)flags;
    inputs[0].U.ki.time = 0;
    inputs[0].U.ki.dwExtraInfo = IntPtr.Zero;

    uint result = SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));
    if (result == 0)
    {
        // optional debug:
        // Console.WriteLine($"SendInput failed for vk={vk}, flags={flags}, error={Marshal.GetLastWin32Error()}");
    }
}

// ---- Win32 interop for SendInput ----

[DllImport("user32.dll", SetLastError = true)]
static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

[StructLayout(LayoutKind.Sequential)]
struct INPUT
{
    public uint type;
    public InputUnion U;
}

[StructLayout(LayoutKind.Explicit)]
struct InputUnion
{
    [FieldOffset(0)]
    public KEYBDINPUT ki;
}

[StructLayout(LayoutKind.Sequential)]
struct KEYBDINPUT
{
    public ushort wVk;
    public ushort wScan;
    public uint dwFlags;
    public uint time;
    public IntPtr dwExtraInfo;
}

[Flags]
enum KeyEventFlags : uint
{
    KEYDOWN  = 0x0000,
    KEYUP    = 0x0002,
    EXTENDED = 0x0001
}
