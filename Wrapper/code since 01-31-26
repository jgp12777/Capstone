
using System;
using System.Net.Sockets; 
using System.Text; 
using System.Globalization;
using System.Net;
using System.Net.WebSockets;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Linq;

// Graceful shutdown handler
var cts = new CancellationTokenSource();
Console.CancelKeyPress += (sender, e) =>
{
    e.Cancel = true; // Prevent immediate termination
    Console.WriteLine("\nShutdown requested...");
    cts.Cancel();
};

//---------------------------------------------------------------------------------
//------------------------simple settings------------------------------------------
//---------------------------------------------------------------------------------

double onThreshold  = 0.6; // turns an action ON
double offThreshold = 0.5; // turns action OFF (hysteresis)
int DebounceMs = 150;         // require actions to stay stable this long
int rateHz = 15;        // cap frequency 
int udpPort = 7400;
int httpPort = 8080;   // used by the WebSocket server (ws://127.0.0.1:8080/stream)

// Security limits
const int MaxWebSocketClients = 100;  // Prevent memory exhaustion
const int MaxPacketsPerSecond = 1000; // UDP flood protection
const int MaxPacketSize = 2048;       // Maximum UDP packet size
const int MaxCsvLength = 256;         // Maximum CSV string length
const int MaxActionNameLength = 50;   // Maximum action name length

bool keyboardMode = false;  // default: OFF for safety
bool verboseLogging = false;

// Parse CLI flags: --keys to enable, --no-keys to force disable, --verbose for detailed logging
foreach (var arg in args)
{
    if (arg.Equals("--keys", StringComparison.OrdinalIgnoreCase))
        keyboardMode = true;
    else if (arg.Equals("--no-keys", StringComparison.OrdinalIgnoreCase))
        keyboardMode = false;
    else if (arg.Equals("--verbose", StringComparison.OrdinalIgnoreCase))
        verboseLogging = true;
}



//---------------------------------------------------------------------------------
//-----------------------Status Variables------------------------------------------
//---------------------------------------------------------------------------------

string active = "neutral";  // confirmed clean action
string candidate = "neutral"; //potential new action 
DateTime candidateSince = DateTime.UtcNow; //when we start considering the action
double lastConfidence = 0.0;     // last seen confidence
DateTime activeSince = DateTime.UtcNow; //When currect action become active
string lastSource = "csv"; // "osc" when we parse OSC successfully
ushort currentKeyDown = 0;  // which virtual key is currently held (0 = none)



//rate limits
int intervalMs = Math.Max(1,(int)Math.Round(1000.0 / rateHz));
DateTime lastPrintAt    =DateTime.MinValue;
string lastPrintedLine = "";
string lastJson = "";        // drop duplicates

// UDP rate limiting
DateTime lastRateLimitReset = DateTime.UtcNow;
int packetsThisSecond = 0;

//webSocket Clients
var clients = new System.Collections.Generic.List<WebSocket>();
object clientslock = new();



Console.WriteLine("------------------------------------------------");
Console.WriteLine("BrainWrapper (UDP → filtered → WebSocket + console)");
Console.WriteLine($"UDP in:           :{udpPort}");
Console.WriteLine($"WebSocket out:    ws://127.0.0.1:{httpPort}/stream");
Console.WriteLine($"HTTP:            http://127.0.0.1:{httpPort}/state , /healthz");
Console.WriteLine("Send:             action,confidence   e.g.  push,0.82");
Console.WriteLine($"Debounce:         {DebounceMs} ms");
Console.WriteLine($"Rate limit:       {rateHz} Hz");
Console.WriteLine($"Keyboard mode:    {(keyboardMode ? "ON  (--keys)" : "OFF (default, use --keys)")}"); 
Console.WriteLine($"Verbose logging:  {(verboseLogging ? "ON  (--verbose)" : "OFF")}");
Console.WriteLine($"Max WS clients:   {MaxWebSocketClients}");
Console.WriteLine($"Max UDP pkt/sec:  {MaxPacketsPerSecond}");
Console.WriteLine("------------------------------------------------");


//---------------------------------------------------------------------------------
//----------------------------------Start websocket server-------------------------
//---------------------------------------------------------------------------------
StartHttpAndWebSocketServer();

using var udp = new UdpClient(new IPEndPoint(IPAddress.Loopback, udpPort));







//---------------------------------MAIN loop------------------------------------------------------------------------
while (!cts.Token.IsCancellationRequested)
{
    try
    {
        if (udp.Available > 0)
        {
            // Rate limit: prevent UDP flood
            var now = DateTime.UtcNow;
            if ((now - lastRateLimitReset).TotalSeconds >= 1.0)
            {
                packetsThisSecond = 0;
                lastRateLimitReset = now;
            }
            
            packetsThisSecond++;
            if (packetsThisSecond > MaxPacketsPerSecond)
            {
                Console.WriteLine($"Warning: UDP rate limit exceeded ({MaxPacketsPerSecond}/sec)");
                await Task.Delay(10); // Back off
                continue;
            }


            var res = await udp.ReceiveAsync(); //1 UDP packet
            if (res.Buffer.Length == 0 || res.Buffer.Length > MaxPacketSize)
            {
                LogVerbose($"Rejected packet: size={res.Buffer.Length} (max={MaxPacketSize})");
                continue;
            }

            string action;
            double conf;

            // 1) Try OSC (binary datagram → address + typetags + args)
            if (TryParseOsc(res.Buffer, out action, out conf))
            {
                lastSource = "osc";
                lastConfidence = conf;
            }
            else
            {
                // 2) Fallback to CSV: "action,confidence"
                string text;
                try
                {
                    text = Encoding.UTF8.GetString(res.Buffer).Trim();
                }
                catch (Exception)
                {
                    LogVerbose("Rejected packet: invalid UTF-8 encoding");
                    continue; // Invalid UTF-8 encoding
                }
                
                // Reject excessively long strings
                if (text.Length > MaxCsvLength)
                {
                    Console.WriteLine($"Warning: Rejected oversized CSV packet (length={text.Length})");
                    continue;
                }
                
                var parts = text.Split(',');
                if (parts.Length != 2) continue;

                action = parts[0].Trim().ToLowerInvariant();
                
                // Validate action name (only alphanumeric and underscore)
                if (string.IsNullOrEmpty(action) || action.Length > MaxActionNameLength || !IsValidActionName(action))
                {
                    Console.WriteLine($"Warning: Rejected invalid action name: {action}");
                    continue;
                }
                
                if (!double.TryParse(parts[1], NumberStyles.Float, CultureInfo.InvariantCulture, out conf))
                    continue;
                    
                // Validate confidence range
                if (conf < 0.0 || conf > 1.0 || double.IsNaN(conf) || double.IsInfinity(conf))
                {
                    Console.WriteLine($"Warning: Rejected invalid confidence value: {conf}");
                    continue;
                }

                lastSource = "csv";
                lastConfidence = conf;
            }

            //----------------------------filters----------------------------------------------------------------------------


            string desired = active; //start from current state
                                     // tiny cleaning rules:
            if (conf >= onThreshold && action != "neutral") // strong singal switch to that action
            {
                desired = action;     // switch to action
            }
            else if (conf < offThreshold) // Weak signal switch to neutral
            {
                desired = "neutral"; // fall back to neutral
            }


            //apply Debounce
            now = DateTime.UtcNow;

            if (desired != candidate)
            {
                // new candidate action; timer resets
                candidate = desired;
                candidateSince = now;
            }
            else
            {
                // candidate stayted the same; check dwell time
                var dwellMs = (now - candidateSince).TotalMilliseconds;
                if (dwellMs >= DebounceMs && active != candidate)
                {
                    active = candidate;      // passed debounce time makes it official
                    activeSince = now;       // reset duration timer
                    UpdateKeyboard(active);  //key sync keyboard with new action
                }

            }
        }
    

    {
        var now = DateTime.UtcNow;
        if ((now - lastPrintAt).TotalMilliseconds >= intervalMs)
        {
            lastPrintAt = now;

            // Build status line for console
            string line = $"active={active}  (candidate={candidate}, conf={lastConfidence:0.00})";

            // Build JSON event for WebSocket clients
            int durationMs = (int)Math.Max(0, (now - activeSince).TotalMilliseconds);
            string json = BuildJson(active, lastConfidence, durationMs, lastSource);

            // Console: only print if it changed
            if (line != lastPrintedLine)
            {
                Console.WriteLine(line);
                lastPrintedLine = line;
            }

            // WebSocket: only broadcast if it changed
            if (json != lastJson)
            {
                await BroadcastAsync(json);
                lastJson = json;
            }
        }
    }

    await Task.Delay(5);

    }
catch (Exception ex)
    {
        //catch errors
        Console.WriteLine($"Warning: {ex.Message}");
    }

}

// Cleanup on shutdown
Console.WriteLine("Releasing any held keys...");
if (keyboardMode && currentKeyDown != 0)
{
    SendKey(currentKeyDown, KeyEventFlags.KEYUP);
}

Console.WriteLine("Closing WebSocket connections...");
lock (clientslock)
{
    foreach (var ws in clients)
    {
        try
        {
            if (ws.State == WebSocketState.Open)
                ws.CloseAsync(WebSocketCloseStatus.NormalClosure, "Server shutdown", CancellationToken.None).Wait(1000);
            ws.Dispose();
        }
        catch { }
    }
    clients.Clear();
}

Console.WriteLine("Shutdown complete.");

//-----------------------------------------------------------------------
// HELPER: BUILD JSON STRING
//-----------------------------------------------------------------------
string BuildJson(string action, double conf, int durationMs, string source)
{
    // Manual JSON construction to avoid reflection issues in .NET 8+
    try
    {
        var ts = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        return $"{{\"ts\":{ts},\"type\":\"mental_command\",\"action\":\"{action}\",\"confidence\":{conf:F2},\"durationMs\":{durationMs},\"raw\":{{\"source\":\"{source}\"}}}}";
    }
    catch (Exception ex)
    {
        Console.WriteLine($"JSON build error: {ex.Message}");
        return "{\"error\":\"serialization_failed\"}";
    }
}



//-----------------------------------------------------------------------
// HELPER: bROADCAST A json message to all websocket clients
//-----------------------------------------------------------------------
async Task BroadcastAsync(string json)
{
    List<WebSocket> deadClients = new();
    
    lock (clientslock)
    {
        if (clients.Count == 0) return;
        
        // Remove dead connections proactively
        clients.RemoveAll(ws => ws.State != WebSocketState.Open && ws.State != WebSocketState.Connecting);
    }

    byte[] msg = Encoding.UTF8.GetBytes(json);
    var tasks = new List<Task>();

    lock (clientslock)
    {
        foreach (var ws in clients)
        {
            if (ws.State == WebSocketState.Open)
            {
                tasks.Add(SendWithTimeout(ws, msg));
            }
            else if (ws.State == WebSocketState.Closed || ws.State == WebSocketState.Aborted)
            {
                deadClients.Add(ws);
            }
        }
    }

    // Clean up dead clients
    if (deadClients.Count > 0)
    {
        lock (clientslock)
        {
            foreach (var ws in deadClients)
                clients.Remove(ws);
        }
    }

    try
    {
        await Task.WhenAll(tasks);
    }
    catch (Exception ex)
    {
        LogVerbose($"Broadcast error: {ex.Message}");
    }
}

async Task SendWithTimeout(WebSocket ws, byte[] msg)
{
    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
    try
    {
        await ws.SendAsync(new ArraySegment<byte>(msg), WebSocketMessageType.Text, true, cts.Token);
    }
    catch (OperationCanceledException)
    {
        LogVerbose("WebSocket send timeout - client may be unresponsive");
    }
    catch (Exception ex)
    {
        LogVerbose($"WebSocket send failed: {ex.Message}");
    }
}

void LogVerbose(string message)
{
    if (verboseLogging)
        Console.WriteLine($"[VERBOSE] {message}");
}

static bool IsValidActionName(string name)
{
    return name.All(c => char.IsLetterOrDigit(c) || c == '_' || c == '-');
}

//-----------------------------------------------------------------------
// OSC PARSER
// Minimal Open Sound Control decoder that can extract:
//   /address ,typetags arg1 arg2 ...
// We only care about a single float argument (e.g. for confidence).
//-----------------------------------------------------------------------
static bool TryParseOsc(byte[] data, out string action, out double conf)
{
    action = null;
    conf = 0.0;

    if (data == null || data.Length < 8 || data.Length > 2048)
        return false;

    try
    {
        int idx = 0;

        // 1) Address (null-terminated C string, 4-byte aligned)
        int addrStart = idx;
        int maxAddrLen = Math.Min(data.Length, 256); // Prevent runaway string parsing
        
        while (idx < maxAddrLen && data[idx] != 0) idx++;
        if (idx >= data.Length || idx >= maxAddrLen) return false;

        string address = Encoding.ASCII.GetString(data, addrStart, idx - addrStart);
        idx++; // skip null
        Align4(ref idx);
        
        if (idx >= data.Length) return false;

        // 2) Type-tag string: e.g. ",f" (comma + 'f' for float, then null, then 4-byte align)
        int typeStart = idx;
        while (idx < data.Length && data[idx] != 0) idx++;
        if (idx >= data.Length) return false;

        string typeTags = Encoding.ASCII.GetString(data, typeStart, idx - typeStart);
        idx++; // skip null
        Align4(ref idx);
        if (idx >= data.Length) return false;

        // We expect ",f" or ",ff" or similar. At least one 'f'.
        if (!typeTags.Contains('f')) return false;

        // 3) Read first float arg
        if (idx + 4 > data.Length) return false;
        float val = ReadFloat32BigEndian(data, idx);
        idx += 4;

        // 4) Parse address for the action name
        //    e.g. "/mentalCommand/push" or "/push"
        var parts = address.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length == 0) return false;

        // For multi-level paths, pick last segment
        // e.g. "/mentalCommand/push" -> "push"
        action = parts[parts.Length - 1].ToLowerInvariant();

        // Convert float to double for conf
        conf = (double)val;

        // Some sanity checks
        if (double.IsNaN(conf) || double.IsInfinity(conf) || conf < 0.0 || conf > 1.0)
            return false;

        return true;
    }
    catch
    {
        return false;
    }

    // Reads 4 bytes as big-endian float
    static float ReadFloat32BigEndian(byte[] data, int idx)
    {
        byte b0 = data[idx];
        byte b1 = data[idx + 1];
        byte b2 = data[idx + 2];
        byte b3 = data[idx + 3];

        if (BitConverter.IsLittleEndian)
            return BitConverter.ToSingle(new byte[] { b3, b2, b1, b0 }, 0);
        return BitConverter.ToSingle(new byte[] { b0, b1, b2, b3 }, 0);
    }

    static void Align4(ref int idx)
    {
        int mod = idx % 4;
        if (mod != 0) idx += (4 - mod);
    }
}


//---------------------------------------------------------------------------------------------------------------------
//-------------------------------START WEB SERVER ON ws://127.0.0.1.:8080/stream
//---------------------------------------------------------------------------------------------------------------------

// Starts a localhost HttpListener that serves:
// - WebSocket on /stream
// - HTTP JSON on /state
// - HTTP health on /healthz
void StartHttpAndWebSocketServer()
{
    Task.Run(async () =>
    {
        var listener = new HttpListener();
        // localhost-only for safety
        listener.Prefixes.Add($"http://127.0.0.1:{httpPort}/");
        try
        {
            listener.Start();
        }
        catch (HttpListenerException ex)
        {
            Console.WriteLine("Error: could not start HTTP/WS server.");
            Console.WriteLine("You may need to run as Administrator or reserve the URL.");
            Console.WriteLine(ex.Message);
            return;
        }

        Console.WriteLine($"HTTP/WS listening on http://127.0.0.1:{httpPort}/  (WS: /stream, HTTP: /state, /healthz)");

        while (!cts.Token.IsCancellationRequested)
        {
            HttpListenerContext ctx;
            try { ctx = await listener.GetContextAsync(); }
            catch { break; } // listener stopped

            // Validate request is from localhost only
            if (!ctx.Request.IsLocal)
            {
                Console.WriteLine($"Warning: Rejected non-local request from {ctx.Request.RemoteEndPoint}");
                ctx.Response.StatusCode = 403;
                ctx.Response.Close();
                continue;
            }

            // Validate URL path to prevent path traversal
            if (ctx.Request.RawUrl.Contains("..") || ctx.Request.RawUrl.Contains("%2e"))
            {
                Console.WriteLine($"Warning: Rejected suspicious URL: {ctx.Request.RawUrl}");
                ctx.Response.StatusCode = 400;
                ctx.Response.Close();
                continue;
            }

            // 1) WebSocket endpoint: /stream
            if (ctx.Request.IsWebSocketRequest && ctx.Request.RawUrl == "/stream")
            {
                try
                {
                    // Enforce maximum client limit
                    lock (clientslock)
                    {
                        if (clients.Count >= MaxWebSocketClients)
                        {
                            Console.WriteLine($"WebSocket connection rejected: maximum {MaxWebSocketClients} clients reached");
                            ctx.Response.StatusCode = 503; // Service Unavailable
                            ctx.Response.Close();
                            continue;
                        }
                    }

                    var wsContext = await ctx.AcceptWebSocketAsync(subProtocol: null);
                    var ws = wsContext.WebSocket;

                    lock (clientslock)
                    {
                        clients.Add(ws);
                        Console.WriteLine($"WebSocket client connected ({clients.Count}/{MaxWebSocketClients})");
                    }

                    // background loop to detect close
                    _ = Task.Run(async () =>
                    {
                        var buffer = new byte[1024];
                        try
                        {
                            while (ws.State == WebSocketState.Open)
                            {
                                var result = await ws.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                                if (result.MessageType == WebSocketMessageType.Close) break;
                            }
                        }
                        catch { /* ignore */ }
                        finally
                        {
                            lock (clientslock)
                            {
                                clients.Remove(ws);
                                Console.WriteLine($"WebSocket client disconnected ({clients.Count}/{MaxWebSocketClients})");
                            }
                            try { ws.Dispose(); } catch { }
                        }
                    });
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"WebSocket accept error: {ex.Message}");
                    ctx.Response.StatusCode = 500;
                    ctx.Response.Close();
                }
                continue;
            }

            // 2) HTTP: /state -> current JSON snapshot
            if (ctx.Request.HttpMethod == "GET" && ctx.Request.RawUrl == "/state")
            {
                string json = BuildJson(
                    active,
                    lastConfidence,
                    (int)Math.Max(0, (DateTime.UtcNow - activeSince).TotalMilliseconds),
                    lastSource);

                byte[] body = Encoding.UTF8.GetBytes(json);
                ctx.Response.StatusCode = 200;
                ctx.Response.ContentType = "application/json";
                ctx.Response.ContentEncoding = Encoding.UTF8;
                await ctx.Response.OutputStream.WriteAsync(body, 0, body.Length);
                ctx.Response.OutputStream.Close();
                continue;
            }

            // 3) HTTP: /healthz -> {"status":"ok"}
            if (ctx.Request.HttpMethod == "GET" && ctx.Request.RawUrl == "/healthz")
            {
                const string ok = "{\"status\":\"ok\"}";
                byte[] body = Encoding.UTF8.GetBytes(ok);
                ctx.Response.StatusCode = 200;
                ctx.Response.ContentType = "application/json";
                ctx.Response.ContentEncoding = Encoding.UTF8;
                await ctx.Response.OutputStream.WriteAsync(body, 0, body.Length);
                ctx.Response.OutputStream.Close();
                continue;
            }

            // 4) Anything else -> small info text
            {
                string info = $"Endpoints: ws /stream , http GET /state , GET /healthz";
                byte[] body = Encoding.UTF8.GetBytes(info);
                ctx.Response.StatusCode = 200;
                ctx.Response.ContentType = "text/plain";
                await ctx.Response.OutputStream.WriteAsync(body, 0, body.Length);
                ctx.Response.OutputStream.Close();
            }
        }
        
        listener.Stop();
    });
}

// -----------------------------------------------------------------------
// KEYBOARD EMULATION 
// Maps actions to WASD using Win32 SendInput.
// -----------------------------------------------------------------------

void UpdateKeyboard(string newAction)
{
    if (!keyboardMode)
        return;

    // Map action -> virtual key code
    ushort? newKey = MapActionToKey(newAction);

    // If we have an old key held down and it's changing or going neutral -> release old key
    if (currentKeyDown != 0 && (!newKey.HasValue || newKey.Value != currentKeyDown))
    {
        SendKey(currentKeyDown, KeyEventFlags.KEYUP);
        currentKeyDown = 0;
    }

    // If new key is non-neutral and different -> press new key
    if (newKey.HasValue && newKey.Value != 0 && newKey.Value != currentKeyDown)
    {
        SendKey(newKey.Value, KeyEventFlags.KEYDOWN);
        currentKeyDown = newKey.Value;
    }
}

// Map mental action -> virtual-key code (WASD)
ushort? MapActionToKey(string action)
{
    switch (action.ToLowerInvariant())
    {
        case "push":  return 0x57; // 'W'
        case "pull":  return 0x53; // 'S'
        case "left":  return 0x41; // 'A'
        case "right": return 0x44; // 'D'
        default:      return null; // neutral or unsupported -> no key
    }
}

// Sends a single key press or release using SendInput.
void SendKey(ushort vk, KeyEventFlags flags)
{
    INPUT[] inputs = new INPUT[1];
    inputs[0].type = 1; // INPUT_KEYBOARD
    inputs[0].U.ki.wVk = vk;
    inputs[0].U.ki.wScan = 0;
    inputs[0].U.ki.dwFlags = (uint)flags;
    inputs[0].U.ki.time = 0;
    inputs[0].U.ki.dwExtraInfo = IntPtr.Zero;

    uint result = SendInput(1, inputs, Marshal.SizeOf(typeof(INPUT)));
    if (result == 0)
    {
        // optional debug:
        // Console.WriteLine($"SendInput failed for vk={vk}, flags={flags}, error={Marshal.GetLastWin32Error()}");
    }
}

// ---- Win32 interop for SendInput ----

[DllImport("user32.dll", SetLastError = true)]
static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

[StructLayout(LayoutKind.Sequential)]
struct INPUT
{
    public uint type;
    public InputUnion U;
}

[StructLayout(LayoutKind.Explicit)]
struct InputUnion
{
    [FieldOffset(0)]
    public KEYBDINPUT ki;
}

[StructLayout(LayoutKind.Sequential)]
struct KEYBDINPUT
{
    public ushort wVk;
    public ushort wScan;
    public uint dwFlags;
    public uint time;
    public IntPtr dwExtraInfo;
}

[Flags]
enum KeyEventFlags : uint
{
    KEYDOWN  = 0x0000,
    KEYUP    = 0x0002,
    EXTENDED = 0x0001
}
